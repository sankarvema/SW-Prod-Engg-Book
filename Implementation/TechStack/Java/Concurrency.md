Java applications tend to be ran as a single process. Within that process, applications can utilize independent "threads"of execution to perform tasks in parallel. A typical Java web server uses hundreds (if not thousands) of threads. Each request to the server is typically handled on it's own thread and modern Java web servers are now generally non-blocking (meaning they yield control of execution back to the processor while they wait for background threads to complete tasks - typically I/O related, like connecting to a database). This is a huge advancement, especially since it (blocking execution) was a major criticism of Java web servers when Node.js first came out

You will conceptually have as many actively executing threads as you have CPU cores. A single Java process (web server or application) can utilize all of the CPU cores on a computer because it can allocate more than one thread. Another (kind of) advantage of threads is that they can share memory. This means you can access variables created by one thread on another, whereas, separate processes cannot. This makes coordination and communication between threads extremely fast - they can simply access the same variables in their process's memory space.

Shared access to memory between threads can also a be great problem. Since multiple threads can access the same memory at the same time, it is completely possible to create scenarios were your application state becomes inconsistent due to concurrent modification and access. One of these scenarios is deadlocking a process[1], where two competing threads are indefinitely stalled because they have independently locked a resource the other is reliant upon. This means that some state needs to be be handled in a synchronous fashion; which requires the coordination of threads around some kind of state boundary (review the Java documentation on locks, synchronize, etc.).

A common consequence of poor state synchronization is dirty mutation. In Java, it is completely possible for two threads to both modify a long or double (64-bit) at the same time (one changing the most significant 32-bits and the other the least significant 32-bits). This happens because Java cannot modify a 64-bit doubles and integer atomically

Simply put, while you can use Java to write near-realtime (stupid fast) applications, it's really hard to do right. This is why there are books like Java Concurrency in Practice teaching developers how to use the platform correctly.
